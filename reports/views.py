# reports/views.py
# pylint: disable=no-member,no-name-in-module
from datetime import timedelta
from django.utils import timezone
from django.db.models import Count
from rest_framework import generics
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import serializers
from rest_framework import status as http_status
from rest_framework import filters
from django.shortcuts import get_object_or_404
from .models import Report, Evidence, ReportMessage, ForumPost, ForumReply, Resource
from .serializers import (
    ReportCreateSerializer, 
    ReportStatusSerializer,
    ReportMessageSerializer,
    ReportMessageCreateSerializer,
    ForumPostSerializer,
    ForumPostDetailSerializer,
    ForumReplyCreateSerializer,
    ResourceSerializer
)
class DashboardStatsView(APIView):
    """
    Provides anonymous, aggregate data for the public dashboard.
    """
    def get(self, request, format=None):  # pylint: disable=redefined-builtin,unused-argument
        # 1. Total Reports
        total_reports = Report.objects.count()

        # 2. Reports in the last 30 days
        last_30_days = timezone.now() - timedelta(days=30)
        recent_reports = Report.objects.filter(created_at__gte=last_30_days).count()

        # 3. Reports resolved or closed
        resolved_reports = Report.objects.filter(
            status__in=[Report.StatusChoices.RESOLVED, Report.StatusChoices.CLOSED]
        ).count()

        # 4. Reports by category
        reports_by_category = Report.objects.values('category').annotate(
            count=Count('category')
        ).order_by('-count')

        # Format category data for the chart
        category_data = {
            'labels': [item['category'] for item in reports_by_category],
            'counts': [item['count'] for item in reports_by_category]
        }

        # 5. Reports currently under review
        in_review_count = Report.objects.filter(status=Report.StatusChoices.IN_REVIEW).count()

        data = {
            'total_reports': total_reports,
            'recent_reports': recent_reports,
            'resolved_reports': resolved_reports,
            'in_review_count': in_review_count,
            'by_category': category_data
        }
        
        return Response(data, status=http_status.HTTP_200_OK)

class ReportCreateView(generics.CreateAPIView):
    """
    API endpoint for creating a new report.
    POST: Creates a new report and returns the case_id.
    """
    queryset = Report.objects.all()  # type: ignore[attr-defined]  # pylint: disable=no-member
    serializer_class = ReportCreateSerializer

    def create(self, request, *args, **kwargs):
        # Get serializer with request context (for file uploads)
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        report = serializer.save()
        
        # Ensure case_id is available (it's generated by default function)
        # Refresh from database to ensure all fields are populated
        report.refresh_from_db()
        
        # Verify case_id exists
        if not report.case_id:
            # This should never happen, but log it if it does
            import logging
            logger = logging.getLogger(__name__)
            logger.error("Report created without case_id: %s", report.id)
            return Response({
                'error': 'Report created but case_id was not generated. Please contact support.'
            }, status=http_status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        return Response({
            'case_id': report.case_id,
            'message': 'Report created successfully'
        }, status=http_status.HTTP_201_CREATED)


class ReportStatusView(generics.RetrieveAPIView):
    """
    API endpoint for retrieving report status by case_id.
    GET: Returns the report details and status for the given case_id.
    """
    queryset = Report.objects.all()  # type: ignore[attr-defined]  # pylint: disable=no-member
    serializer_class = ReportStatusSerializer
    lookup_field = 'case_id'
    lookup_url_kwarg = 'case_id'


# --- ADD THIS NEW VIEW ---

class ReportChatView(generics.ListCreateAPIView):
    """
    API endpoint for listing and creating chat messages for a report.
    GET: Returns all messages for the given case_id.
    POST: Creates a new message for the given case_id (from the user).
    """
    
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return ReportMessageCreateSerializer
        return ReportMessageSerializer

    def get_queryset(self):
        """
        Filter messages based on the case_id in the URL.
        """
        case_id = self.kwargs['case_id']
        try:
            report = Report.objects.get(case_id=case_id)  # type: ignore[attr-defined]  # pylint: disable=no-member
            return ReportMessage.objects.filter(report=report).order_by('created_at')  # type: ignore[attr-defined]  # pylint: disable=no-member
        except Report.DoesNotExist:  # type: ignore[attr-defined]  # pylint: disable=no-member
            return ReportMessage.objects.none()  # type: ignore[attr-defined]  # pylint: disable=no-member

    def perform_create(self, serializer):
        """
        When a user posts a message, automatically link it to the report
        and set the sender_type to 'User'.
        """
        case_id = self.kwargs['case_id']
        try:
            report = Report.objects.get(case_id=case_id)  # type: ignore[attr-defined]  # pylint: disable=no-member
            serializer.save(
                report=report, 
                sender_type=ReportMessage.SenderTypeChoices.USER
            )
        except Report.DoesNotExist as exc:  # type: ignore[attr-defined]  # pylint: disable=no-member
            raise serializers.ValidationError("Invalid Case ID") from exc


# --- FORUM VIEWS ---

class ForumPostListCreateView(generics.ListCreateAPIView):
    """
    GET: Returns a list of all forum posts.
    POST: Creates a new forum post.
    """
    serializer_class = ForumPostSerializer
    
    def get_queryset(self):
        # Annotate with reply count for the serializer
        return ForumPost.objects.annotate(  # type: ignore[attr-defined]  # pylint: disable=no-member
            reply_count=Count('replies')
        ).order_by('-created_at')


class ForumPostDetailView(generics.RetrieveAPIView):
    """
    GET: Returns a single forum post and its replies.
    """
    queryset = ForumPost.objects.all()  # type: ignore[attr-defined]  # pylint: disable=no-member
    serializer_class = ForumPostDetailSerializer
    lookup_field = 'pk'  # Use the post ID (pk)


class ForumReplyCreateView(generics.CreateAPIView):
    """
    POST: Creates a new reply for a specific post.
    """
    queryset = ForumReply.objects.all()  # type: ignore[attr-defined]  # pylint: disable=no-member
    serializer_class = ForumReplyCreateSerializer

    def perform_create(self, serializer):
        # Find the post using the 'post_pk' from the URL
        post = get_object_or_404(ForumPost, pk=self.kwargs['post_pk'])  # type: ignore[attr-defined]  # pylint: disable=no-member
        serializer.save(post=post)

        # --- ADD THIS NEW VIEW ---
class ResourceListView(generics.ListAPIView):
    """
    Provides a list of all resources, searchable by name and description.
    """
    queryset = Resource.objects.all()
    serializer_class = ResourceSerializer
    filter_backends = [filters.SearchFilter]
    search_fields = ['name', 'description', 'category']

class ResourceDetailView(generics.RetrieveAPIView):
    """
    Provides a single resource by ID.
    """
    queryset = Resource.objects.all()
    serializer_class = ResourceSerializer
    filter_backends = [filters.SearchFilter]
    search_fields = ['name', 'description', 'category']
    
    
